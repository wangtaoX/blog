<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>奔跑的蚂蚁</title>
 <link href="http://wangtaox.github.io/atom.xml" rel="self"/>
 <link href="http://wangtaox.github.io"/>
 <updated>2016-07-27T16:02:29+08:00</updated>
 <id>http://wangtaox.github.io/</id>
 <author>
   <name>TaoWang</name>
 </author>

 
 <entry>
   <title>&quot;CSS secrets&quot; Reading Notes</title>
   <link href="http://wangtaox.github.io/2016/05/14/css-secret-reading-notes.html"/>
   <updated>2016-05-14T00:00:00+08:00</updated>
   <id>http://wangtaox.github.io/2016/05/14/css-secret-reading-notes</id>
   <content type="html">&lt;h3&gt;currentColor&lt;/h3&gt;

&lt;p&gt;In css3, we got a special new color keyword &lt;strong&gt;currentColor&lt;/strong&gt;, which always resolves to the value of the &lt;strong&gt;color&lt;/strong&gt; property, make it &lt;strong&gt;the first ever variable&lt;/strong&gt; in css.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;CSS&quot;&gt;.dont-do-this {
  height: 2em;
  width: 1em;
  background: currentColor;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will become even more useful when we get functions to manipulate colors in native css.&lt;/p&gt;

&lt;h3&gt;Use shorthands wisely&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;CSS&quot;&gt;.positive-bg {
  background: blue;
  /*background-color: blue;*/
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is good defensive coding and future-proofing to use them, unless we intentionally want to use cascaded properties.&lt;/p&gt;

&lt;h3&gt;background-clip&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;CSS&quot;&gt;.photo-box {
  border: .4em solid rgba(255, 255, 255, .5);
  border-radius: .4em;
  font-size: 120%;
  line-height: 1.5;
  width: 720px;
  background: rgba(255, 255, 255);
  background-clip: padding-box;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;outline&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;outline&lt;/strong&gt; do not fellow the elements’s rounding but &lt;strong&gt;box-shadow&lt;/strong&gt; do&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;.box {
  background: blue;
  border-radius: .8em;
  padding: 1em;
  box-shadow: 0 0 0 .8em red;
  outline: .8em solid red;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;linear-gradient&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;.bg {
  background: linear-gradient(red 20%, blue 80%);
  ....
  /* 80% － 20% is the length of gradient area */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we set the color position at 0, it means its position is set to where the previous one stop.&lt;/p&gt;

&lt;h3&gt;box-shadow&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;.box {
  box-shadow: 0 0 10px blue;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;z-index&lt;/h3&gt;

&lt;p&gt;First of all, z-index only works on positioned elements. If you try to set a z-index on an element with no position specified, it will do nothing. Secondly, z-index values can create stacking contexts.&lt;/p&gt;

&lt;p&gt;Every stacking context has a single HTML element as its root element. When a new stacking context is formed on an element, that stacking context confines all of its child elements to a particular place in the stacking order, That means that if an element is contained in a stacking context at the bottom of the stacking order, there is no way to get it to appear in front of another element in a different stacking context that is higher in the stacking order, even with a z-index of a billion!&lt;/p&gt;

&lt;p&gt;New stacking contexts can be formed on an element in one of three ways:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;When an element is the root element of a document (the &lt;strong&gt;html&lt;/strong&gt; element)&lt;/li&gt;
&lt;li&gt;When an element has a position value other than static and a z-index value other than auto&lt;/li&gt;
&lt;li&gt;When an element has an opacity value less than 1&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;In addition to opacity, several newer CSS properties also create stacking contexts. These include: transforms, filters, css-regions, paged media, and possibly others. As a general rule, it seems that if a CSS property requires rendering in an offscreen context, it must create a new stacking context.&lt;/p&gt;

&lt;p&gt;Here are the basic rules to determine stacking order within a single stacking context (from back to front):&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The stacking context’s root element&lt;/li&gt;
&lt;li&gt;Positioned elements (and their children) with negative z-index values (higher values are stacked in front of lower values; elements with the same value are stacked according to appearance in the HTML)&lt;/li&gt;
&lt;li&gt;Non-positioned elements (ordered by appearance in the HTML)&lt;/li&gt;
&lt;li&gt;Positioned elements (and their children) with a z-index value of auto (ordered by appearance in the HTML)&lt;/li&gt;
&lt;li&gt;Positioned elements (and their children) with positive z-index values (higher values are stacked in front of lower values; elements with the same value are stacked according to appearance in the HTML)&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Note: positioned elements with negative z-indexes are ordered first within a stacking context, which means they appear behind all other elements. Because of this, it becomes possible for an element to appear behind its own parent, which is normally not possible. This will only work if the element’s parent is in the same stacking context and is not the root element of that stacking context.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>&quot;flip&quot;动画</title>
   <link href="http://wangtaox.github.io/2016/03/28/flip.html"/>
   <updated>2016-03-28T00:00:00+08:00</updated>
   <id>http://wangtaox.github.io/2016/03/28/flip</id>
   <content type="html">&lt;h3&gt;flip动画&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;first: 元素在动画中的初始状态&lt;/li&gt;
&lt;li&gt;last: 元素的动画的结束状态&lt;/li&gt;
&lt;li&gt;invert: 计算first和last状态的差值，然后设置相应的属性(transform, opacity等)，使元素在初始状态。&lt;/li&gt;
&lt;li&gt;play: 触发整个动画&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;一个例子🌰&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;head&amp;gt;
  &amp;lt;style media=&quot;screen&quot;&amp;gt;
    body {
    }

    .container {
      width: 100%;
      height: 100%;
      margin: 0 auto;
      background: #BBDEFB;
      position: relative;
    }

    .circle {
      width: 100px;
      height: 100px;
      border-radius: 100%;
      background-color: #E1BEE7;
      position: absolute;
      top: 10px;
      left: 10px;
    }

    .circle-end {
      top: auto;
      left: auto;
      bottom: 10px;
      right: 10px;
    }

  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;button type=&quot;button&quot; name=&quot;button&quot; onclick=&quot;doAnimate()&quot;&amp;gt;Animate&amp;lt;/button&amp;gt;
  &amp;lt;div class=&quot;container&quot;&amp;gt;
    &amp;lt;div class=&quot;circle&quot;&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
  function doAnimate() {
    var node = document.getElementsByClassName(&#39;circle&#39;)[0]

    //计算初始属性
    var first = node.getBoundingClientRect()
    node.classList.add(&#39;circle-end&#39;)
    //计算结束属性
    var last = node.getBoundingClientRect()

    //invert
    var invertX = first.left - last.left
    var invertY = first.top - last.top

    node.style.transform = &#39;translate(&#39; + invertX + &#39;px,&#39; + invertY + &#39;px)&#39;
    node.style.transition = &#39;transform 0s&#39;

    requestAnimationFrame(function(node) {
      return function() {

        //触发动画
        node.style.transition = &#39;all 1s&#39;;
        node.style.transform  = &#39;&#39;;
        console.log(node)
      }
    }(node))
  }

  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;requestAnimationFrame函数&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame&quot;&gt;requestAnimationFrame&lt;/a&gt;函数主要告诉浏览器在重绘每一帧动画时，可以运行用户定义的代码，可以进行相应的计算等等。&lt;/p&gt;

&lt;h4&gt;参考资料&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/developers-writing/animating-the-unanimatable-1346a5aab3cd#.86itpf3ga&quot;&gt;Animating the Unanimatable.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://aerotwist.com/blog/flip-your-animations/&quot;&gt;FLIP Your Animations&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>理解javascript promise</title>
   <link href="http://wangtaox.github.io/2016/03/04/promise.html"/>
   <updated>2016-03-04T00:00:00+08:00</updated>
   <id>http://wangtaox.github.io/2016/03/04/promise</id>
   <content type="html">&lt;h3&gt;so promise ？&lt;/h3&gt;

&lt;p&gt;promise，翻译过来就是承诺的意思，在javascript中，promise是一个关于异步操作的结果的“承诺”,
可以在&lt;a href=&quot;https://promisesaplus.com/&quot;&gt;promise A+ spec&lt;/a&gt;中了解更多关于promise的信息。&lt;/p&gt;

&lt;p&gt;在此翻译了pouchdb中关于promise的博客，以加深对promise的理解。&lt;a href=&quot;https://twitter.com/nolanlawson&quot;&gt;作者&lt;/a&gt;在推上发了一段关于promise的代码，如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;//case 1
doSomething().then(function() {
    return doSomethingElse()
})
//case 2
doSomething().then(function() {
    doSomethingElse()
})
//case 3
doSomething().then(doSomethingElse())
//case 4
doSomething().then(doSomethingElse)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意: &lt;code&gt;doSomething&lt;/code&gt;及&lt;code&gt;doSomethingElse&lt;/code&gt;都是一个函数并返回新的promise.&lt;/p&gt;

&lt;p&gt;知道几个case的区别么? #@!...以下代码可能会使用一些ES6语法。&lt;/p&gt;

&lt;h3&gt;坑1: 回调金字塔&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;getUsersFromRESTAPI().then((resultOfUsers) =&amp;gt; {
    resultOfUsers.forEach((user) =&amp;gt; {
        localStorageWithPromise.put(user).then(() =&amp;gt; {
            console.log(`put user ${user.name} to localStorage success!`)
        }).catch((err) =&amp;gt; {
            console.log(`put user ${user.name} to localStorage failed!`)
            localStorageWithPromise.remove(user.id).then(() =&amp;gt; {
                console.log(`remove possible user info with user id : ${user.id}`)
            })
            ...
        })
    })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样当我们需要完成更复杂的一些回调操作时，可能代码比这还嵌套得深，这样代码的可读性以及可维护性就会很糟糕，而更好的书写
方式应该这样，称为&lt;code&gt;组合promise&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;getUsersFromRESTAPI().then(resultOfUsers =&amp;gt; {
    return Promise.all(resultOfUsers.forEach((user) =&amp;gt; {
        return localStorageWithPromise.put(user)
    }))
}).then((resultInfo) =&amp;gt; {
    console.log(`put result ${resultInfo}`)
}).catch((err) =&amp;gt; {
    console.log(err)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更直观一点，或许我们应该组织我们的promise调用链如下面这样的方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;operationA().then((resultOfA) =&amp;gt; {
    return doWithResultA(resultOfA)
}).then((resultFromA) =&amp;gt; {
    return operationB(resultFromA)
}).then((resultFromB) =&amp;gt; {
    return operationC(resultFromB)
}).catch(err =&amp;gt; {
    console.log(`any errors &quot;${err}&quot; happened in promise chain`)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样整个调用链会比较清晰，且可以统一的&lt;code&gt;catch&lt;/code&gt;错误并处理。&lt;/p&gt;

&lt;h3&gt;坑2: forEach与promise&lt;/h3&gt;

&lt;p&gt;比如如下的操作:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;getUsersFromRESTAPI().then(resultOfUsers =&amp;gt; {
    resultOfUsers.forEach(user =&amp;gt; {
        user.remove()
    })
}).then(() =&amp;gt; {
    //以为已经删除了所有用户
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很多时候我们以为这样写就可以了，其实是错误的，第二个then回调并不会等待所有user被删除才执行，因为在第一个then回调中，函数返回
的是&lt;code&gt;undefined&lt;/code&gt;, 所以这样的写法就会存在bug, 正确的写法应该如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;getUsersFromRESTAPI().then(resultOfUsers =&amp;gt; {
    return Promise.all(resultOfUsers.forEach(user =&amp;gt; {
        return user.remove()
    }))
}).then(() =&amp;gt; {
    console.log(&quot;all users has been deleted.&quot;)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在第一个then回调中返回了promise，并使用了&lt;code&gt;promise.all&lt;/code&gt;, 注意&lt;code&gt;user.remove&lt;/code&gt;也是返回promise的。&lt;/p&gt;

&lt;h3&gt;坑3: 忘记catch错误&lt;/h3&gt;

&lt;p&gt;我们不应该去假设我们的promise不返回任何错误，应该在promise调用中都进行正确的错误处理.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;promise1().then(() =&amp;gt; {
    return opReturnPromise2()
}).then(() =&amp;gt; {
    return opReturnPromise3()
}).catch(err =&amp;gt; {
    //handle errors properly.
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;promise中的返回值&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;promise1().then(() =&amp;gt; {
    opReturnPromise2()
}).then(() =&amp;gt; {
    opReturnPromise3()
}).catch(err =&amp;gt; {
    //handle errors properly.
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有什么问题么？这儿在promise的回调中&lt;code&gt;返回值存在问题&lt;/code&gt;, 在promise中，then()回调可以返回:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;返回另一个promise.&lt;/li&gt;
&lt;li&gt;返回一个值(或者undefined).&lt;/li&gt;
&lt;li&gt;返回一个错误.&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;返回另一个promise&lt;/h4&gt;

&lt;p&gt;这就是上面提到的&lt;code&gt;组合promise&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;promise1().then(() =&amp;gt; {
    return opReturnPromise2()
}).then(() =&amp;gt; {
    return opReturnPromise3()
}).catch(err =&amp;gt; {
    //handle errors properly.
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;返回一个值(或者undefined)&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;getUserFromRESTAPI(userName).then((userInfo) =&amp;gt; {
    if (FriendsCache[userInfo.id]) {
        return FriendsCache[userInfo.id]
    }
    return getUserFriends(userInfo.id)
}).then((friends) =&amp;gt; {
    console.log(friends)
}).catch(err =&amp;gt; {
    console.log(err)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样写是不是很清晰，在第二个处理friends的then回调中，我不需要关心friends是在cache中还是从API中获取的，处理得到的好友列表即可。
由于在javascript中，函数不显视的返回任何值，则返回undefined，所有在promise的then回调中，建议总是返回一个值或者抛出错误。&lt;/p&gt;

&lt;h4&gt;返回一个错误&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;getUserFromRESTAPI(userName).then((userInfo) =&amp;gt; {
    if (isLoggedout(userInfo.id)) {
        throw new Error(&quot;logged out!&quot;)
    }
    if (FriendsCache[userInfo.id]) {
        return FriendsCache[userInfo.id]
    }
    return getUserFriends(userInfo.id)
}).then((friends) =&amp;gt; {
    console.log(friends)
}).catch(err =&amp;gt; {
    console.log(err)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;巧用Promose.resolve&lt;/h3&gt;

&lt;p&gt;使用promise包装同步的代码使其异步化，并进行错误处理。对于同步的操作，promise也可以提供很多帮助，比如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;let caculateSomethingAndMayThrowError  = (x, y) =&amp;gt; {
    if (x &amp;lt; y) {
        throw new Error(&quot;x &amp;lt; y&quot;)
    }
    return x - y
}

let wrapAPI2Promise = () =&amp;gt; {
    return Promise.resolve().then(() =&amp;gt; {
        let value = caculateSomethingAndMayThrowError()
        return value
    }).then((value) =&amp;gt; {
        console.log(value)
    }).catch((err) =&amp;gt; {
        console.log(err)
    })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在catch中我们可以处理同步函数抛出的异常.&lt;/p&gt;

&lt;h3&gt;避免reject函数，使用catch&lt;/h3&gt;

&lt;p&gt;catch函数其实是一个语法糖, 如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;promise1().catch((err) =&amp;gt; {})
//equal to
promise1().then(null, (err) =&amp;gt; {})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如下的代码却并不一样，如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;promise1().then(() =&amp;gt; {
    return promise2()
}).catch((err) =&amp;gt; {
    console.log(err)
})

promise1().then(() =&amp;gt; {
    return promise2()
}, (err) =&amp;gt; {
    console.log(err)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个catch会处理整个promise链中的异常错误，但是第二个却是处理promise1的异常错误，因为它相当于promise1的reject函数。
所以一般情况下建议只用catch函数，避免给then传递第二个参数导致理解错误，出现bug。&lt;/p&gt;

&lt;h3&gt;promise工厂函数&lt;/h3&gt;

&lt;p&gt;有时可以通过工厂函数，组合我们的promise链，但是一定要注意返回值, 例如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;//依次sleep 1s

let suspendOneSecondFactory = () =&amp;gt; {
    return () =&amp;gt; {
        return new Promise((resolve, reject) =&amp;gt; {
            setTimeout(() =&amp;gt; {
                console.log(&#39;sleep 1s&#39;)
                resolve()
            }, 1000)
        })
    }
}

let result = Promise.resolve()
[1, 2, 3].forEach(() =&amp;gt; {
    result = result.then(suspendOneSecondFactory())
})
result.then(() =&amp;gt; {
    console.log(&quot;the end&quot;)
}).catch(err =&amp;gt; {
    console.log(err)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;总结&lt;/h3&gt;

&lt;p&gt;promise在使用时一定要注意then回调的返回值，以及组合使用promise，并将操作尽量步骤化，那样可以使用proise链组合出各种需要的
依赖链并进行调用, 如果给then调用传递非函数值，在then调用中传递的非函数值会被解析为null。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>golang grpc学习</title>
   <link href="http://wangtaox.github.io/2016/02/01/grpc.html"/>
   <updated>2016-02-01T00:00:00+08:00</updated>
   <id>http://wangtaox.github.io/2016/02/01/grpc</id>
   <content type="html">&lt;p&gt;使用gRPC构建文件传输服务&lt;/p&gt;

&lt;h3&gt;grpc简介&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.grpc.io/&quot;&gt;grpc&lt;/a&gt;是Google开源的rpc框架，使用&lt;a href=&quot;https://developers.google.com/protocol-buffers/&quot;&gt;protobuf&lt;/a&gt;进行数据编码，，基于Http2协议，提供了很多优势，比如:双向的数据流，流控制，包头压缩，多路复用等，详细信息可以参考grpc官网。&lt;/p&gt;

&lt;h3&gt;protobuf3&lt;/h3&gt;

&lt;p&gt;protobuf是Google提供的一个跨语言的数据编码机制，支持多种语言，在结合RPC使用时，可以节省带宽，提高传输效率，grpc提供了protobuf的相应工具，这样就可以使用proto文件定义RPC接口，约定传输数据格式，通过生成工具生成相应语言的源文件。&lt;/p&gt;

&lt;h3&gt;定义一个文件传输服务&lt;/h3&gt;

&lt;p&gt;以下为一个文件服务的proto文件定义, file.proto :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;protocol&quot;&gt;syntax ＝ &quot;proto3&quot;;

package filetransfer;

//rpc调用定义
service FileServer {
  rpc GetFile(FileDescriptor) returns (stream FileContent) {}
}

message FileDescriptor {
  string filename = 1;
}

message FileContent {
  bytes content = 1;
  string md5sum = 2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过工具生成相应语言源代码，以&lt;a href=&quot;http://golang.org&quot;&gt;golang&lt;/a&gt;为例，使用如下命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;protoc --go_out=plugins=grpc:. file.proto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下是服务端的代码实现:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;go&quot;&gt;const (
  BUFSIZE = 1024
)

func (am *AgentManager) GetFile(fd *pb.FileDescriptor, stream pb.FileServer_GetFileServer) error {
  filename := fd.Filename

  //make sure file existed.
  fo, err := os.Open(filename)
  if err != nil {
    return ErrNoSuchFile
  }
  defer func() {
      if err := fo.Close(); err != nil {
        panic(err)
      }
  }()

  content := &amp;amp;pb.FileContent {
    Content: make([]byte, BUFSIZE),
    Md5Sum: caculateMd5(filename),
  }
  for {
    n, err := fo.Read(content.Content)
    if err != nil &amp;amp;&amp;amp; err != io.EOF {
      return ErrReadFile
    }
    if n == 0 {
      break
    }

    if err := stream.Send(content); err != nil {
      return err
    }
  }

  //indicate the end of stream.
  return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下是Client端代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;go&quot;&gt;
func ReadFile(filename string, conn pb.FileServerClient) error {
  stream, err := conn.GetFile(filename)
  if err != nil {
    panic(err)
  }

  outFd, err := os.Create(filename)
  if err != nil {
    panic(err)
  }
  defer func() {
      if err := outFd.Close(); err != nil {
        panic(err)
      }
  }()

  for {
    content, err := stream.Recv()
    if err == io.EOF {
      break
    }
    if err != nil {
      panic(err)
    }

    if err := outFd.Write(content.Content); err != nil {
      panic(err)
    }
  }

  return nil
}


func checkMd5(filename string, md5 string) bool {
  return caculateMd5(filename) == md5
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码有部分省略.&lt;/p&gt;

&lt;h3&gt;grpc stream&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;protobuf&quot;&gt;syntax = &quot;proto3&quot;;

package chatservice;

service chatservice {
  //双向的stream
  rpc chat(stream ChatMessage) returns (ChatMessage) {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;grpc的stream可以是双向的也可以是单向的，在通过proto文件定义时指定，比如: 也可以实现如Chat这样的接口。&lt;/p&gt;

&lt;h3&gt;参考链接&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://talks.golang.org/2015/gotham-grpc.slide#1&quot;&gt;go-grpc-slides&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://coreos.com/blog/gRPC-protobufs-swagger.html&quot;&gt;Rest &amp;amp; gRPC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/coreos/etcd/blob/master/etcdserver/etcdserverpb/rpc.proto&quot;&gt;etcdv3 API proto&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/gengo/grpc-gateway&quot;&gt;gRPC rest gateway&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>openstack rpc实现源码分析</title>
   <link href="http://wangtaox.github.io/2015/11/21/rpc.html"/>
   <updated>2015-11-21T00:00:00+08:00</updated>
   <id>http://wangtaox.github.io/2015/11/21/rpc</id>
   <content type="html">&lt;h3&gt;RabbitMQ的消息模型&lt;/h3&gt;

&lt;h4&gt;RabbitMQ 基本概念:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Producer: 消息生产者&lt;/li&gt;
&lt;li&gt;Consumer: 消息消费者&lt;/li&gt;
&lt;li&gt;Exchange: 接受消息的载体&lt;/li&gt;
&lt;li&gt;Message: RabbitMQ中的基本消息单元&lt;/li&gt;
&lt;li&gt;Queue: 存储并接受Exchange分发的消息, 用于Consumer接受消息&lt;/li&gt;
&lt;li&gt;Routing Key: 标识Message, 用于Exchange分发消息的依据&lt;/li&gt;
&lt;li&gt;Binding: Queue与Exchange绑定, 可选的binding key参数用于指定特定的消息(相当于消息的routing key)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在RabbitMQ中, 消息是发送给&lt;code&gt;Exchange&lt;/code&gt;的, 而不是&lt;code&gt;Queue&lt;/code&gt;, &lt;code&gt;Producer&lt;/code&gt;将带有&lt;code&gt;Routing Key&lt;/code&gt;的消息发送给相应的
&lt;code&gt;Exchange&lt;/code&gt;后, 整个消息的发送过程就结束了; 消息的接收是通过&lt;code&gt;Queue&lt;/code&gt;完成的, &lt;code&gt;Consumer&lt;/code&gt;在RabbitMQ中定义
一个&lt;code&gt;Queue&lt;/code&gt;, 与相应的&lt;code&gt;Exchange&lt;/code&gt;进行&lt;code&gt;Binding&lt;/code&gt;, 在&lt;code&gt;Binding&lt;/code&gt;时可指定感兴趣的消息, 通过&lt;code&gt;binding key&lt;/code&gt;来完成,这
样消息就会被&lt;code&gt;Exchange&lt;/code&gt;根据&lt;code&gt;binding key&lt;/code&gt;分发到相应的&lt;code&gt;Queue&lt;/code&gt;上,  &lt;code&gt;Consumer&lt;/code&gt;接受&lt;code&gt;Queue&lt;/code&gt;的消息即可,
这样整个消息的接收就完成了.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.rabbitmq.com/img/tutorials/python-three-overall.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示, &lt;code&gt;P&lt;/code&gt;代表&lt;code&gt;Producer&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt;代表&lt;code&gt;Exchange&lt;/code&gt;, 红色的代表&lt;code&gt;Queue&lt;/code&gt;以及相应的queue name, binding表示上
述的&lt;code&gt;Binding&lt;/code&gt;过程, &lt;code&gt;C&lt;/code&gt;代表&lt;code&gt;Consumer&lt;/code&gt;.&lt;/p&gt;

&lt;h4&gt;RabbitMQ中的Exchange&lt;/h4&gt;

&lt;p&gt;Exchange在RabbitMQ中也有相应的分类:&lt;code&gt;Direct&lt;/code&gt; &lt;code&gt;Fanout&lt;/code&gt; &lt;code&gt;Topic&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Exchange的分类是为了实现不同的通信模式&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fanout: 消息将分发给所有与&lt;code&gt;Exchange&lt;/code&gt;绑定的&lt;code&gt;Queue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Direct: 消息将通过 &lt;em&gt;完全匹配&lt;/em&gt; &lt;code&gt;Routing Key&lt;/code&gt;分发到相应的&lt;code&gt;Queue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Topic: 消息将通过 &lt;em&gt;正则匹配(支持特殊字符)&lt;/em&gt; &lt;code&gt;Routing Key&lt;/code&gt;分发到相应的&lt;code&gt;Queue&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;因此, 当使用&lt;code&gt;Fanout&lt;/code&gt;类型的&lt;code&gt;Exchange&lt;/code&gt;, 消息将分发至所有与该&lt;code&gt;Exchange&lt;/code&gt;绑定的&lt;code&gt;Queue&lt;/code&gt;上, 此时不会匹配&lt;code&gt;Routing Key&lt;/code&gt;,
当使用&lt;code&gt;Direct&lt;/code&gt;类型的&lt;code&gt;Exchange&lt;/code&gt;, 消息将通过&lt;em&gt;完全匹配&lt;/em&gt;(&lt;code&gt;Routing Key&lt;/code&gt;与&lt;code&gt;Binding Key&lt;/code&gt;)被分发至相应的&lt;code&gt;Queue&lt;/code&gt;, 同理,
&lt;code&gt;Topic&lt;/code&gt;类型的&lt;code&gt;Exchange&lt;/code&gt;会进行&lt;em&gt;正则匹配&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;如图, &lt;code&gt;Direct Exchange&lt;/code&gt;类型的消息模型:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.rabbitmq.com/img/tutorials/direct-exchange.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图, &lt;code&gt;Topic Exchange&lt;/code&gt;类型的消息模型:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.rabbitmq.com/img/tutorials/python-five.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从两种类型的&lt;code&gt;Exchange&lt;/code&gt;可以看出, 区别仅在于分发消息时对于&lt;code&gt;Routing Key&lt;/code&gt;的匹配方式, &lt;code&gt;Direct&lt;/code&gt;是&lt;em&gt;完全匹配&lt;/em&gt;&lt;code&gt;Queue&lt;/code&gt;的&lt;code&gt;Binding Key&lt;/code&gt;,
&lt;code&gt;Topic&lt;/code&gt;则是使用&lt;em&gt;正则匹配&lt;/em&gt;.&lt;/p&gt;

&lt;h3&gt;Openstack RPC&lt;/h3&gt;

&lt;p&gt;在Openstack中, 组件内的通信主要通过消息队列完成, 这样可以使整个系统以松耦合的方式进行协作, 以RabbitMQ为例,
Openstack实现了组件间的RPC调用, 主要包括&lt;em&gt;同步&lt;/em&gt;和&lt;em&gt;异步&lt;/em&gt;两种调用方式:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;    &quot;&quot;&quot;oslo/messaging/rpc/client.py&quot;&quot;&quot;
    class RPCClient(object):

        &quot;&quot;&quot;A class for invoking methods on remote servers.
        The RPCClient class is responsible for sending method invocations to remote
        servers via a messaging transport.

        A cast() invocation just sends the request and returns immediately. 
        A call() invocation waits for the server to send a return value.
        &quot;&quot;&quot;

        def cast(self, ctxt, method, **kwargs):
            &quot;&quot;&quot;Invoke a method and return immediately.
            &quot;&quot;&quot;
            self.prepare().cast(ctxt, method, **kwargs)
        def call(self, ctxt, method, **kwargs):
            &quot;&quot;&quot;Invoke a method and wait for a reply.
            &quot;&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;插入的代码只是RPCClient实现的一部分, 从注释可以看出, &lt;code&gt;cast函数&lt;/code&gt;属于异步调用, &lt;code&gt;call函数&lt;/code&gt;属于同步调用.&lt;/p&gt;

&lt;h4&gt;cast实现方式&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://docs.openstack.org/developer/nova/_images/flow2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;rpc调用方会初始化&lt;code&gt;Topic Publisher&lt;/code&gt;, 将消息以&lt;code&gt;Routing Key&lt;/code&gt;为topic发送至配置的&lt;code&gt;Exchange&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;&lt;p&gt;rpc接收方会初始化两个&lt;code&gt;Topic Cosumer&lt;/code&gt;, 分别通过topic和topic.host为&lt;code&gt;binding key&lt;/code&gt;将&lt;code&gt;Queue&lt;/code&gt;与&lt;code&gt;Exchange&lt;/code&gt;绑定,
这样接收方就可以接收这两种类型的rpc message&lt;/p&gt;

&lt;p&gt;  &lt;code&gt;topic&lt;/code&gt;即为消息的&lt;code&gt;Routing Key&lt;/code&gt;, 所以接收方可以接受到调用方的rpc message.&lt;br&gt;
  &lt;code&gt;topic.host&lt;/code&gt;为特定的host上的接收方获取rpc message的方式, 例如: l3-agent.host1(通知host1上的l3-agent进行相关rpc调用)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;call实现方式&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://docs.openstack.org/developer/nova/_images/flow1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;rpc调用方初始化&lt;code&gt;Topic Publisher&lt;/code&gt;用于发送rpc message, 同时初始化一个&lt;code&gt;Direct Consumer&lt;/code&gt;用于接收返回的rpc调用结果,
为了保证收到相应的rpc调用的结果, rpc message中会保存一个唯一标识该消息的messga id(UUID类型), 消息以&lt;code&gt;Routing Key&lt;/code&gt;为topic发送至
&lt;code&gt;Exchange&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;rpc接收方会初始化两个&lt;code&gt;Topic Cosumer&lt;/code&gt;, 分别通过topic和topic.host为&lt;code&gt;binding key&lt;/code&gt;将&lt;code&gt;Queue&lt;/code&gt;与&lt;code&gt;Exchange&lt;/code&gt;绑定, rpc
接收方执行rpc调用, 完成后通过&lt;code&gt;Direct Publisher&lt;/code&gt;将结果发送到消息队列中, 返回的执行结果message的&lt;code&gt;Routing Key&lt;/code&gt;为message id
(唯一的UUID), 将被发送至&lt;code&gt;Exchange&lt;/code&gt;(名称同样是唯一的message id), 那样调用方的&lt;code&gt;Direct Consumer&lt;/code&gt;就可以收到rpc调用的结果了.&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;以ovs_neutron_agent为例理解rpc的实现&lt;/h4&gt;

&lt;p&gt;在ovs_neutron_agent的代码中, rpc的初始化如下:
~~~python
    &quot;&quot;&quot;plugins/openvswitch/agent/ovs_neutron_agent.py&quot;&quot;&quot;
    def setup_rpc(self):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ......
    #作为rpc调用方的初始化
    self.plugin_rpc = OVSPluginApi(topics.PLUGIN)   #与ml2 plgin通信
    self.state_rpc = agent_rpc.PluginReportStateAPI(topics.PLUGIN)

    #作为rpc接收方的初始化
    self.topic = topics.AGENT
    # Handle updates from service
    self.endpoints = [self]
    # Define the listening consumers for the agent
    consumers = [[topics.PORT, topics.UPDATE],
                 [topics.NETWORK, topics.DELETE],
                 [constants.TUNNEL, topics.UPDATE],
                 [topics.SECURITY_GROUP, topics.UPDATE],
                 [topics.DVR, topics.UPDATE]]
    if self.l2_pop:
        consumers.append([topics.L2POPULATION,
                          topics.UPDATE, cfg.CONF.host])
    self.connection = agent_rpc.create_consumers(self.endpoints,
                                                 self.topic,
                                                 consumers)
    ......
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
self.topic为ovs_neutron_agent会接收的rpc message的类型前缀, 在topics.py中定义:
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&quot;&quot;&quot;common/topics.py&quot;&quot;&quot;
AGENT = &#39;q-agent-notifier&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;在neutron中, 消息可以分为不同的类型, 以AGENT=&#39;q-agent-notifier&#39;为例, 表示为通知agent端的消息类型.

self.consumers为ovs_neutron_agent会接收的rpc message的具体类型, 在agent_rpc.create_consumers()函数中, 完成了consumers的初始化:
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&quot;&quot;&quot;agent/rpc.py&quot;&quot;&quot;
def create_consumers(endpoints, prefix, topic_details):
    &quot;&quot;&quot;
    :param endpoints: The list of endpoints to process the incoming messages.
    :param prefix: Common prefix for the plugin/agent message queues.
    :param topic_details: A list of topics. Each topic has a name, an
                          operation, and an optional host param keying the
                          subscription to topic.host for plugin calls.
    &quot;&quot;&quot;

    connection = n_rpc.create_connection(new=True)
    for details in topic_details:
        topic, operation, node_name = itertools.islice(
            itertools.chain(details, [None]), 3)

        topic_name = topics.get_topic_name(prefix, topic, operation)
        connection.create_consumer(topic_name, endpoints, fanout=True)
        if node_name: #node_name即为host name
            node_topic_name = &#39;%s.%s&#39; % (topic_name, node_name)
            connection.create_consumer(node_topic_name,
                                       endpoints,
                                       fanout=False)
    connection.consume_in_threads()
    return connection
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
这里需要关注的就是create\_consumer函数, 以及传递给该函数的参数topic_name, endpoints, 对于fanout参数, 当
host存在时, 就不需要fanout类型, 因为只需要特定的host接收. topic\_name为prefix + topic + operation, 例如:
`q-agent-notifier-port-update`, `q-agent-notifier-port-update.hostname`, `q-agent-notifier-security_grout-update`等, 
这些例子就会作为topic_name传递给create_consumer函数, endpoints为执行rpc函数的载体, 此处应该传递的:
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;    self.endpoints = [self]  #上面的setup_rpc函数中, 即为实例本身
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;def get_server(target, endpoints, serializer=None):
    assert TRANSPORT is not None
    serializer = RequestContextSerializer(serializer)
    return messaging.get_rpc_server(TRANSPORT, target, endpoints,
                                    &#39;eventlet&#39;, serializer)

class Connection(object):

    def __init__(self):
        super(Connection, self).__init__()
        self.servers = []

    def create_consumer(self, topic, endpoints, fanout=False):
        target = messaging.Target(
            topic=topic, server=cfg.CONF.host, fanout=fanout)
        server = get_server(target, endpoints)
        self.servers.append(server)

    def consume_in_threads(self):
        for server in self.servers:
            server.start()
        return self.servers

# functions
def create_connection(new=True):
    return Connection()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
在create_consumer函数中, 首先初始化target, 其作用是封装了关于rpc message相关联的属性, 
比如该消息发送到的`Exchange`, 消息的topic(Routing Key)等.

&amp;gt; 注意: 在neutron中, 消息的topic其实就是消息发送进`Exchange`所带有的`Routing Key`, 比如以topic `q-agent-notifier-port-update`
&amp;gt; 为例, 与port-update相关的rpc message应该都是`Routing Key`为`q-agent-notifier-port-update`的.

然后在get_server函数中, serializer为序列化rpc消息的函数, 用于将raw rpc message序列化为适合neutron上下文的dict, 可以不用
深入去看, 明白其含义即可, TRANSPORT为消息的传递载体, 因为openstack中可以使用rabbitmq, 以及zeromq等消息队列, TRANSPOST主要
完成了对相应消息队列功能的封装, 这儿以rabbitmq为消息队列, 也就是说, 消息是通过TRANSPORT(rabbimq)传递的.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;def get_rpc_server(transport, target, endpoints,
                   executor=&#39;blocking&#39;, serializer=None):
    &quot;&quot;&quot;Construct an RPC server.

    The executor parameter controls how incoming messages will be received and
    dispatched. By default, the most simple executor is used - the blocking
    executor.

    :param transport: the messaging transport
    :type transport: Transport
    :param target: the exchange, topic and server to listen on
    :type target: Target
    :param endpoints: a list of endpoint objects
    :type endpoints: list
    :param executor: name of a message executor - for example
                     &#39;eventlet&#39;, &#39;blocking&#39;
    :type executor: str
    :param serializer: an optional entity serializer
    :type serializer: Serializer
    &quot;&quot;&quot;
    dispatcher = rpc_dispatcher.RPCDispatcher(target, endpoints, serializer)
    return msg_server.MessageHandlingServer(transport, dispatcher, executor)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
在messaging.get_rpc_server函数中, 进行了dispatcher的初始化, 它的主要作用为从TRANSPORT中接受感兴趣的消息, 
而target描述了这些感兴趣的消息的属性, target记录了这些信息.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;class MessageHandlingServer(object):
    &quot;&quot;&quot;Server for handling messages.

    Connect a transport to a dispatcher that knows how to process the
    message using an executor that knows how the app wants to create
    new tasks.
    &quot;&quot;&quot;

    def __init__(self, transport, dispatcher, executor=&#39;blocking&#39;):
        &quot;&quot;&quot;Construct a message handling server.

        The dispatcher parameter is a callable which is invoked with context
        and message dictionaries each time a message is received.

        The executor parameter controls how incoming messages will be received
        and dispatched. By default, the most simple executor is used - the
        blocking executor.

        :param transport: the messaging transport
        :type transport: Transport
        :param dispatcher: a callable which is invoked for each method
        :type dispatcher: callable
        :param executor: name of message executor - for example
                         &#39;eventlet&#39;, &#39;blocking&#39;
        :type executor: str
        &quot;&quot;&quot;
        self.conf = transport.conf

        self.transport = transport
        self.dispatcher = dispatcher
        self.executor = executor

        try:
            mgr = driver.DriverManager(&#39;oslo.messaging.executors&#39;,
                                       self.executor)
        except RuntimeError as ex:
            raise ExecutorLoadFailure(self.executor, ex)
        else:
            self._executor_cls = mgr.driver
            self._executor = None

        super(MessageHandlingServer, self).__init__()

    def start(self):
        &quot;&quot;&quot;Start handling incoming messages.
        &quot;&quot;&quot;
        if self._executor is not None:
            return
        try:
            listener = self.dispatcher._listen(self.transport)
        except driver_base.TransportDriverError as ex:
            raise ServerListenError(self.target, ex)

        self._executor = self._executor_cls(self.conf, listener,
                                            self.dispatcher)
        self._executor.start()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
接下来在MessageHandlingServer(transport, dispatcher, executor)中, executor为&#39;blocking&#39;, 表示rpc函数的执行会
阻塞当前线程, 相应的参数还有&#39;eventlet&#39;, 表示在新的eventlet线程中执行, 我们也不需要关心这部分内容, 但是
需要明白其作用. 在上面的start函数中, listener为dispatcher的_listen所返回的结果, 从listener中, 我们就可以
接收到一个一个的消息了, 然后通过self._executor.start(), 开始获取消息并进行相应的rpc调用.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;def spawn_with(ctxt, pool):
    &quot;&quot;&quot;This is the equivalent of a with statement
    but with the content of the BLOCK statement executed
    into a greenthread

    exception path grab from:
    http://www.python.org/dev/peps/pep-0343/
    &quot;&quot;&quot;

    def complete(thread, exit):
        exc = True
        try:
            try:
                thread.wait()
            except Exception:
                exc = False
                if not exit(*sys.exc_info()):
                    raise
        finally:
            if exc:
                exit(None, None, None)

    callback = ctxt.__enter__()
    thread = pool.spawn(callback)
    thread.link(complete, ctxt.__exit__)

    return thread

class EventletExecutor(base.ExecutorBase):

    &quot;&quot;&quot;A message executor which integrates with eventlet.

    This is an executor which polls for incoming messages from a greenthread
    and dispatches each message in its own greenthread.

    The stop() method kills the message polling greenthread and the wait()
    method waits for all message dispatch greenthreads to complete.
    &quot;&quot;&quot;

    def __init__(self, conf, listener, dispatcher):
        super(EventletExecutor, self).__init__(conf, listener, dispatcher)
        self.conf.register_opts(_eventlet_opts)
        self._thread = None
        self._greenpool = greenpool.GreenPool(self.conf.rpc_thread_pool_size)
        self._running = False

    def start(self):
        if self._thread is not None:
            return

        @excutils.forever_retry_uncaught_exceptions
        def _executor_thread():
            try:
                while self._running:
                    incoming = self.listener.poll(timeout=base.POLL_TIMEOUT)
                    if incoming is not None:
                        spawn_with(ctxt=self.dispatcher(incoming),
                                   pool=self._greenpool)
            except greenlet.GreenletExit:
                return

        self._running = True
        self._thread = eventlet.spawn(_executor_thread)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
在self.\_executor的实现中, start函数的self.listener.poll()函数不断获取rpc消息, 并将新消息在新的eventlet thread中执行, 其中spwan_with中会产生
新的thread, 同时传递给spwan\_with的参数为ctxt=self.dispatcher(incoming), 需要特别注意, 因为dispatcher实现了[\_\_call\_\_][1]方法, 由于
self.dispatcher是一个可调用对象, 因此ctxt=self.dispatcher(incoming)这样的调用是可行的.

现在我们就可以看看在dispatcher中, 消息是怎样得到处理的.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;class RPCDispatcher(object):
    &quot;&quot;&quot;A message dispatcher which understands RPC messages.

    A MessageHandlingServer is constructed by passing a callable dispatcher
    which is invoked with context and message dictionaries each time a message
    is received.

    RPCDispatcher is one such dispatcher which understands the format of RPC
    messages. The dispatcher looks at the namespace, version and method values
    in the message and matches those against a list of available endpoints.

    Endpoints may have a target attribute describing the namespace and version
    of the methods exposed by that object. All public methods on an endpoint
    object are remotely invokable by clients.
    &quot;&quot;&quot;

    def __init__(self, target, endpoints, serializer):
        &quot;&quot;&quot;Construct a rpc server dispatcher.

        :param target: the exchange, topic and server to listen on
        :type target: Target
        &quot;&quot;&quot;

        self.endpoints = endpoints
        self.serializer = serializer or msg_serializer.NoOpSerializer()
        self._default_target = msg_target.Target()
        self._target = target

    def _listen(self, transport):
        return transport._listen(self._target)

    @staticmethod
    def _is_namespace(target, namespace):
        return namespace == target.namespace

    @staticmethod
    def _is_compatible(target, version):
        endpoint_version = target.version or &#39;1.0&#39;
        return utils.version_is_compatible(endpoint_version, version)

    def _do_dispatch(self, endpoint, method, ctxt, args):
        ctxt = self.serializer.deserialize_context(ctxt)
        new_args = dict()
        for argname, arg in six.iteritems(args):
            new_args[argname] = self.serializer.deserialize_entity(ctxt, arg)
        result = getattr(endpoint, method)(ctxt, **new_args)
        return self.serializer.serialize_entity(ctxt, result)

    @contextlib.contextmanager
    def __call__(self, incoming):
        incoming.acknowledge()
        yield lambda: self._dispatch_and_reply(incoming)

    def _dispatch_and_reply(self, incoming):
        try:
            incoming.reply(self._dispatch(incoming.ctxt,
                                          incoming.message))
        except ExpectedException as e:
            LOG.debug(u&#39;Expected exception during message handling (%s)&#39;,
                      e.exc_info[1])
            incoming.reply(failure=e.exc_info, log_failure=False)
        except Exception as e:
            # sys.exc_info() is deleted by LOG.exception().
            exc_info = sys.exc_info()
            LOG.error(_(&#39;Exception during message handling: %s&#39;), e,
                      exc_info=exc_info)
            incoming.reply(failure=exc_info)
            # NOTE(dhellmann): Remove circular object reference
            # between the current stack frame and the traceback in
            # exc_info.
            del exc_info

    def _dispatch(self, ctxt, message):
        &quot;&quot;&quot;Dispatch an RPC message to the appropriate endpoint method.

        :param ctxt: the request context
        :type ctxt: dict
        :param message: the message payload
        :type message: dict
        :raises: NoSuchMethod, UnsupportedVersion
        &quot;&quot;&quot;
        method = message.get(&#39;method&#39;)
        args = message.get(&#39;args&#39;, {})
        namespace = message.get(&#39;namespace&#39;)
        version = message.get(&#39;version&#39;, &#39;1.0&#39;)

        found_compatible = False
        for endpoint in self.endpoints:
            target = getattr(endpoint, &#39;target&#39;, None)
            if not target:
                target = self._default_target

            if not (self._is_namespace(target, namespace) and
                    self._is_compatible(target, version)):
                continue

            if hasattr(endpoint, method): #从endpoint中获取相应的rpc method
                localcontext.set_local_context(ctxt) #执行rpc调用
                try:
                    return self._do_dispatch(endpoint, method, ctxt, args) #返回序列化的结果
                finally:
                    localcontext.clear_local_context()

            found_compatible = True

        if found_compatible:
            raise NoSuchMethod(method)
        else:
            raise UnsupportedVersion(version, method=method)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
在\_\_call\_\_方法中, 返回的[lambda][2]即为: self._dispatch_and_reply(incoming), 然后消息会在\_dispatch函数中被处理并返回相应的
rpc调用的结果.

#### Transport如何通过Target获取相应的消息
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;    def _listen(self, transport):
        return transport._listen(self._target)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
在上面dispatcher的实现中, 可以看到_listen函数是通过tranport.\_listen实现的, 并相应的传递了self._target作为参数.
因此, 我们可以通过理解Transport的实现来理解openstack neutron中topic的含义.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;class Transport(object):
    &quot;&quot;&quot;A messaging transport.
    This is a mostly opaque handle for an underlying messaging transport
    driver.
    It has a single &#39;conf&#39; property which is the cfg.ConfigOpts instance used
    to construct the transport object.
    &quot;&quot;&quot;
    def __init__(self, driver):
        self.conf = driver.conf
        self._driver = driver

    def _send(self, target, ctxt, message, wait_for_reply=None, timeout=None,
              retry=None):
        if not target.topic:
            raise exceptions.InvalidTarget(&#39;A topic is required to send&#39;,
                                           target)
        return self._driver.send(target, ctxt, message,
                                 wait_for_reply=wait_for_reply,
                                 timeout=timeout, retry=retry)

    def _send_notification(self, target, ctxt, message, version, retry=None):
        if not target.topic:
            raise exceptions.InvalidTarget(&#39;A topic is required to send&#39;,
                                           target)
        self._driver.send_notification(target, ctxt, message, version,
                                       retry=retry)

    def _listen(self, target):
        if not (target.topic and target.server):
            raise exceptions.InvalidTarget(&#39;A server\&#39;s target must have &#39;
                                           &#39;topic and server names specified&#39;,
                                           target)
        return self._driver.listen(target) #相应的实现在driver中实现
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
可以看到, 不同的transport都实现了listen函数, 以rabbitmq的实现为例, driver代码如下:
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;class AMQPDriverBase(base.BaseDriver):

    def __init__(self, conf, url, connection_pool,
                 default_exchange=None, allowed_remote_exmods=None):
        super(AMQPDriverBase, self).__init__(conf, url, default_exchange,
                                             allowed_remote_exmods)

        self._default_exchange = default_exchange

        self._connection_pool = connection_pool

        self._reply_q_lock = threading.Lock()
        self._reply_q = None
        self._reply_q_conn = None
        self._waiter = None

    def _get_exchange(self, target):
        return target.exchange or self._default_exchange

    def _get_connection(self, pooled=True):
        return rpc_amqp.ConnectionContext(self._connection_pool,
                                          pooled=pooled)

    def _get_reply_q(self):
        with self._reply_q_lock:
            if self._reply_q is not None:
                return self._reply_q

            reply_q = &#39;reply_&#39; + uuid.uuid4().hex

            conn = self._get_connection(pooled=False)

            self._waiter = ReplyWaiter(self.conf, reply_q, conn,
                                       self._allowed_remote_exmods)

            self._reply_q = reply_q
            self._reply_q_conn = conn

        return self._reply_q

    def _send(self, target, ctxt, message,
              wait_for_reply=None, timeout=None,
              envelope=True, notify=False, retry=None):

        # FIXME(markmc): remove this temporary hack
        class Context(object):
            def __init__(self, d):
                self.d = d

            def to_dict(self):
                return self.d

        context = Context(ctxt)
        msg = message

        if wait_for_reply:
            msg_id = uuid.uuid4().hex
            msg.update({&#39;_msg_id&#39;: msg_id})
            LOG.debug(&#39;MSG_ID is %s&#39;, msg_id)
            msg.update({&#39;_reply_q&#39;: self._get_reply_q()})

        rpc_amqp._add_unique_id(msg)
        rpc_amqp.pack_context(msg, context)

        if envelope:
            msg = rpc_common.serialize_msg(msg)

        if wait_for_reply:
            self._waiter.listen(msg_id)

        try:
            with self._get_connection() as conn:
                if notify:
                    conn.notify_send(self._get_exchange(target),
                                     target.topic, msg, retry=retry)
                elif target.fanout:
                    conn.fanout_send(target.topic, msg, retry=retry)
                else:
                    topic = target.topic
                    if target.server:
                        topic = &#39;%s.%s&#39; % (target.topic, target.server)
                    conn.topic_send(exchange_name=self._get_exchange(target),
                                    topic=topic, msg=msg, timeout=timeout,
                                    retry=retry)

            if wait_for_reply:
                result = self._waiter.wait(msg_id, timeout)
                if isinstance(result, Exception):
                    raise result
                return result
        finally:
            if wait_for_reply:
                self._waiter.unlisten(msg_id)

    def send(self, target, ctxt, message, wait_for_reply=None, timeout=None,
             retry=None):
        return self._send(target, ctxt, message, wait_for_reply, timeout,
                          retry=retry)

    def send_notification(self, target, ctxt, message, version, retry=None):
        return self._send(target, ctxt, message,
                          envelope=(version == 2.0), notify=True, retry=retry)

    def listen(self, target):
        conn = self._get_connection(pooled=False)

        listener = AMQPListener(self, conn)

        conn.declare_topic_consumer(exchange_name=self._get_exchange(target), #定义Topic Consumer
                                    topic=target.topic,
                                    callback=listener)
        conn.declare_topic_consumer(exchange_name=self._get_exchange(target),
                                    topic=&#39;%s.%s&#39; % (target.topic,
                                                     target.server),
                                    callback=listener)
        conn.declare_fanout_consumer(target.topic, listener)

        return listener

    def listen_for_notifications(self, targets_and_priorities, pool):
        conn = self._get_connection(pooled=False)

        listener = AMQPListener(self, conn)
        for target, priority in targets_and_priorities:
            conn.declare_topic_consumer(
                exchange_name=self._get_exchange(target),
                topic=&#39;%s.%s&#39; % (target.topic, priority),
                callback=listener, queue_name=pool)
        return listener
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;~~~&lt;/p&gt;

&lt;p&gt;从上面listen的代码, 就回到了rpc call和rpc cast模型, 定义Topic Consumer, 但是为什么会初始化3个&lt;code&gt;Consumer&lt;/code&gt;呢？&lt;/p&gt;

&lt;p&gt;这要从rpc方法调用的方式说起, rpc call和 rpc cast有两种方式: topic + topic.host, rpc fanout_cast有一种方式: fanout, 所以对应的&lt;code&gt;Consumer&lt;/code&gt;
也有3种, 因为在消息的接收方看来, 我不需要关心消息是以什么方式传输过来的, 无论是rpc call, 或者rpc cast, 或rpc fanout_cast, 对于
消息本身才是它需要关心的, 因此它可以接收三种方式发送过来的消息, 所以会初始化3种&lt;code&gt;Consumer&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;总结&lt;/h3&gt;

&lt;p&gt;结合RabbbitMQ的基本概念, 不难看出, openstack中与rpc调用相关的topic, 对消息发送方(rpc调用方)来说, 它就是
消息的&lt;code&gt;Routing Key&lt;/code&gt;, 对于消息接收方(rpc接受方), 它就是初始化&lt;code&gt;Consumer&lt;/code&gt;时用于接受消息的&lt;code&gt;Queue&lt;/code&gt;的名称,
且&lt;code&gt;Queue&lt;/code&gt;与&lt;code&gt;Exchange&lt;/code&gt;的Binding Key也为它.&lt;/p&gt;

&lt;h3&gt;参考网站&lt;/h3&gt;

&lt;p&gt;RabbitMQ:   &lt;a href=&quot;http://www.rabbitmq.com/&quot;&gt;http://www.rabbitmq.com/&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 
</feed>
